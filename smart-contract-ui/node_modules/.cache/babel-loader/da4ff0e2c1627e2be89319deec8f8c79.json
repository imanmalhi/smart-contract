{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\nvar SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\nvar SturdyWebSocket = /** @class */function () {\n  function SturdyWebSocket(url, protocolsOrOptions, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.url = url;\n    this.onclose = null;\n    this.onerror = null;\n    this.onmessage = null;\n    this.onopen = null;\n    this.ondown = null;\n    this.onreopen = null;\n    this.CONNECTING = SturdyWebSocket.CONNECTING;\n    this.OPEN = SturdyWebSocket.OPEN;\n    this.CLOSING = SturdyWebSocket.CLOSING;\n    this.CLOSED = SturdyWebSocket.CLOSED;\n    this.hasBeenOpened = false;\n    this.isClosed = false;\n    this.messageBuffer = [];\n    this.nextRetryTime = 0;\n    this.reconnectCount = 0;\n    this.lastKnownExtensions = \"\";\n    this.lastKnownProtocol = \"\";\n    this.listeners = {};\n    if (protocolsOrOptions == null || typeof protocolsOrOptions === \"string\" || Array.isArray(protocolsOrOptions)) {\n      this.protocols = protocolsOrOptions;\n    } else {\n      options = protocolsOrOptions;\n    }\n    this.options = applyDefaultOptions(options);\n    if (!this.options.wsConstructor) {\n      if (typeof WebSocket !== \"undefined\") {\n        this.options.wsConstructor = WebSocket;\n      } else {\n        throw new Error(\"WebSocket not present in global scope and no \" + \"wsConstructor option was provided.\");\n      }\n    }\n    this.openNewWebSocket();\n  }\n  Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n    get: function () {\n      return this.binaryTypeInternal || \"blob\";\n    },\n    set: function (binaryType) {\n      this.binaryTypeInternal = binaryType;\n      if (this.ws) {\n        this.ws.binaryType = binaryType;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n    get: function () {\n      var sum = this.ws ? this.ws.bufferedAmount : 0;\n      var hasUnknownAmount = false;\n      this.messageBuffer.forEach(function (data) {\n        var byteLength = getDataByteLength(data);\n        if (byteLength != null) {\n          sum += byteLength;\n        } else {\n          hasUnknownAmount = true;\n        }\n      });\n      if (hasUnknownAmount) {\n        this.debugLog(\"Some buffered data had unknown length. bufferedAmount()\" + \" return value may be below the correct amount.\");\n      }\n      return sum;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n    get: function () {\n      return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n    get: function () {\n      return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n    get: function () {\n      return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  SturdyWebSocket.prototype.close = function (code, reason) {\n    this.disposeSocket(code, reason);\n    this.shutdown();\n    this.debugLog(\"WebSocket permanently closed by client.\");\n  };\n  SturdyWebSocket.prototype.send = function (data) {\n    if (this.isClosed) {\n      throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n    } else if (this.ws && this.ws.readyState === this.OPEN) {\n      this.ws.send(data);\n    } else {\n      this.messageBuffer.push(data);\n    }\n  };\n  SturdyWebSocket.prototype.reconnect = function () {\n    if (this.isClosed) {\n      throw new Error(\"Cannot call reconnect() on socket which is permanently closed.\");\n    }\n    this.disposeSocket(1000, \"Client requested reconnect.\");\n    this.handleClose(undefined);\n  };\n  SturdyWebSocket.prototype.addEventListener = function (type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n    this.listeners[type].push(listener);\n  };\n  SturdyWebSocket.prototype.dispatchEvent = function (event) {\n    return this.dispatchEventOfType(event.type, event);\n  };\n  SturdyWebSocket.prototype.removeEventListener = function (type, listener) {\n    if (this.listeners[type]) {\n      this.listeners[type] = this.listeners[type].filter(function (l) {\n        return l !== listener;\n      });\n    }\n  };\n  SturdyWebSocket.prototype.openNewWebSocket = function () {\n    var _this = this;\n    if (this.isClosed) {\n      return;\n    }\n    var _a = this.options,\n      connectTimeout = _a.connectTimeout,\n      wsConstructor = _a.wsConstructor;\n    this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n    var ws = new wsConstructor(this.url, this.protocols);\n    ws.onclose = function (event) {\n      return _this.handleClose(event);\n    };\n    ws.onerror = function (event) {\n      return _this.handleError(event);\n    };\n    ws.onmessage = function (event) {\n      return _this.handleMessage(event);\n    };\n    ws.onopen = function (event) {\n      return _this.handleOpen(event);\n    };\n    this.connectTimeoutId = setTimeout(function () {\n      // If this is running, we still haven't opened the websocket.\n      // Kill it so we can try again.\n      _this.clearConnectTimeout();\n      _this.disposeSocket();\n      _this.handleClose(undefined);\n    }, connectTimeout);\n    this.ws = ws;\n  };\n  SturdyWebSocket.prototype.handleOpen = function (event) {\n    var _this = this;\n    if (!this.ws || this.isClosed) {\n      return;\n    }\n    var allClearResetTime = this.options.allClearResetTime;\n    this.debugLog(\"WebSocket opened.\");\n    if (this.binaryTypeInternal != null) {\n      this.ws.binaryType = this.binaryTypeInternal;\n    } else {\n      this.binaryTypeInternal = this.ws.binaryType;\n    }\n    this.clearConnectTimeout();\n    if (this.hasBeenOpened) {\n      this.dispatchEventOfType(\"reopen\", event);\n    } else {\n      this.dispatchEventOfType(\"open\", event);\n      this.hasBeenOpened = true;\n    }\n    this.messageBuffer.forEach(function (message) {\n      return _this.send(message);\n    });\n    this.messageBuffer = [];\n    this.allClearTimeoutId = setTimeout(function () {\n      _this.clearAllClearTimeout();\n      _this.nextRetryTime = 0;\n      _this.reconnectCount = 0;\n      var openTime = allClearResetTime / 1000 | 0;\n      _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" + \" retry time and count.\");\n    }, allClearResetTime);\n  };\n  SturdyWebSocket.prototype.handleMessage = function (event) {\n    if (this.isClosed) {\n      return;\n    }\n    this.dispatchEventOfType(\"message\", event);\n  };\n  SturdyWebSocket.prototype.handleClose = function (event) {\n    var _this = this;\n    if (this.isClosed) {\n      return;\n    }\n    var _a = this.options,\n      maxReconnectAttempts = _a.maxReconnectAttempts,\n      shouldReconnect = _a.shouldReconnect;\n    this.clearConnectTimeout();\n    this.clearAllClearTimeout();\n    if (this.ws) {\n      this.lastKnownExtensions = this.ws.extensions;\n      this.lastKnownProtocol = this.ws.protocol;\n      this.disposeSocket();\n    }\n    this.dispatchEventOfType(\"down\", event);\n    if (this.reconnectCount >= maxReconnectAttempts) {\n      this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n      return;\n    }\n    var willReconnect = !event || shouldReconnect(event);\n    if (typeof willReconnect === \"boolean\") {\n      this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);\n    } else {\n      willReconnect.then(function (willReconnectResolved) {\n        if (_this.isClosed) {\n          return;\n        }\n        _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n      });\n    }\n  };\n  SturdyWebSocket.prototype.handleError = function (event) {\n    this.dispatchEventOfType(\"error\", event);\n    this.debugLog(\"WebSocket encountered an error.\");\n  };\n  SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {\n    if (willReconnect) {\n      this.reestablishConnection();\n    } else {\n      this.stopReconnecting(event, denialReason);\n    }\n  };\n  SturdyWebSocket.prototype.reestablishConnection = function () {\n    var _this = this;\n    var _a = this.options,\n      minReconnectDelay = _a.minReconnectDelay,\n      maxReconnectDelay = _a.maxReconnectDelay,\n      reconnectBackoffFactor = _a.reconnectBackoffFactor;\n    this.reconnectCount++;\n    var retryTime = this.nextRetryTime;\n    this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n    setTimeout(function () {\n      return _this.openNewWebSocket();\n    }, retryTime);\n    var retryTimeSeconds = retryTime / 1000 | 0;\n    this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n  };\n  SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {\n    this.debugLog(debugReason);\n    this.shutdown();\n    if (event) {\n      this.dispatchEventOfType(\"close\", event);\n    }\n  };\n  SturdyWebSocket.prototype.shutdown = function () {\n    this.isClosed = true;\n    this.clearAllTimeouts();\n    this.messageBuffer = [];\n    this.disposeSocket();\n  };\n  SturdyWebSocket.prototype.disposeSocket = function (closeCode, reason) {\n    if (!this.ws) {\n      return;\n    }\n    // Use noop handlers instead of null because some WebSocket\n    // implementations, such as the one from isomorphic-ws, raise a stink on\n    // unhandled events.\n    this.ws.onerror = noop;\n    this.ws.onclose = noop;\n    this.ws.onmessage = noop;\n    this.ws.onopen = noop;\n    this.ws.close(closeCode, reason);\n    this.ws = undefined;\n  };\n  SturdyWebSocket.prototype.clearAllTimeouts = function () {\n    this.clearConnectTimeout();\n    this.clearAllClearTimeout();\n  };\n  SturdyWebSocket.prototype.clearConnectTimeout = function () {\n    if (this.connectTimeoutId != null) {\n      clearTimeout(this.connectTimeoutId);\n      this.connectTimeoutId = undefined;\n    }\n  };\n  SturdyWebSocket.prototype.clearAllClearTimeout = function () {\n    if (this.allClearTimeoutId != null) {\n      clearTimeout(this.allClearTimeoutId);\n      this.allClearTimeoutId = undefined;\n    }\n  };\n  SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {\n    var _this = this;\n    switch (type) {\n      case \"close\":\n        if (this.onclose) {\n          this.onclose(event);\n        }\n        break;\n      case \"error\":\n        if (this.onerror) {\n          this.onerror(event);\n        }\n        break;\n      case \"message\":\n        if (this.onmessage) {\n          this.onmessage(event);\n        }\n        break;\n      case \"open\":\n        if (this.onopen) {\n          this.onopen(event);\n        }\n        break;\n      case \"down\":\n        if (this.ondown) {\n          this.ondown(event);\n        }\n        break;\n      case \"reopen\":\n        if (this.onreopen) {\n          this.onreopen(event);\n        }\n        break;\n    }\n    if (type in this.listeners) {\n      this.listeners[type].slice().forEach(function (listener) {\n        return _this.callListener(listener, event);\n      });\n    }\n    return !event || !event.defaultPrevented;\n  };\n  SturdyWebSocket.prototype.callListener = function (listener, event) {\n    if (typeof listener === \"function\") {\n      listener.call(this, event);\n    } else {\n      listener.handleEvent.call(this, event);\n    }\n  };\n  SturdyWebSocket.prototype.debugLog = function (message) {\n    if (this.options.debug) {\n      // tslint:disable-next-line:no-console\n      console.log(message);\n    }\n  };\n  SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {\n    var maxReconnectAttempts = this.options.maxReconnectAttempts;\n    return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n  };\n  SturdyWebSocket.DEFAULT_OPTIONS = {\n    allClearResetTime: 5000,\n    connectTimeout: 5000,\n    debug: false,\n    minReconnectDelay: 1000,\n    maxReconnectDelay: 30000,\n    maxReconnectAttempts: Number.POSITIVE_INFINITY,\n    reconnectBackoffFactor: 1.5,\n    shouldReconnect: function () {\n      return true;\n    },\n    wsConstructor: undefined\n  };\n  SturdyWebSocket.CONNECTING = 0;\n  SturdyWebSocket.OPEN = 1;\n  SturdyWebSocket.CLOSING = 2;\n  SturdyWebSocket.CLOSED = 3;\n  return SturdyWebSocket;\n}();\nexports.default = SturdyWebSocket;\nfunction applyDefaultOptions(options) {\n  var result = {};\n  Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(function (key) {\n    var value = options[key];\n    result[key] = value === undefined ? SturdyWebSocket.DEFAULT_OPTIONS[key] : value;\n  });\n  return result;\n}\nfunction getDataByteLength(data) {\n  if (typeof data === \"string\") {\n    // UTF-16 strings use two bytes per character.\n    return 2 * data.length;\n  } else if (data instanceof ArrayBuffer) {\n    return data.byteLength;\n  } else if (data instanceof Blob) {\n    return data.size;\n  } else {\n    return undefined;\n  }\n}\nfunction pluralize(s, n) {\n  return n === 1 ? s : s + \"s\";\n}\nfunction noop() {\n  // Nothing.\n}","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["export interface Options {\n    allClearResetTime?: number;\n    connectTimeout?: number;\n    debug?: boolean;\n    minReconnectDelay?: number;\n    maxReconnectDelay?: number;\n    maxReconnectAttempts?: number;\n    reconnectBackoffFactor?: number;\n    wsConstructor?: new (url: string, protocols?: string | string[]) => any;\n    shouldReconnect?(closeEvent: CloseEvent): boolean | Promise<boolean>;\n}\n\ninterface SturdyWebSocketEventMap extends WebSocketEventMap {\n    down: CloseEvent;\n    reopen: Event;\n}\n\ntype WebSocketListener<K extends keyof SturdyWebSocketEventMap> = (\n    this: WebSocket,\n    event: SturdyWebSocketEventMap[K],\n) => any;\n\ntype WebSocketListeners = {\n    [K in keyof SturdyWebSocketEventMap]?: Array<WebSocketListener<K>>;\n} & {\n    [key: string]: EventListenerOrEventListenerObject[];\n};\n\nconst SHOULD_RECONNECT_FALSE_MESSAGE =\n    \"Provided shouldReconnect() returned false. Closing permanently.\";\nconst SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE =\n    \"Provided shouldReconnect() resolved to false. Closing permanently.\";\n\nexport default class SturdyWebSocket implements WebSocket {\n    public static readonly DEFAULT_OPTIONS: Required<Options> = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: () => true,\n        wsConstructor: undefined!,\n    };\n\n    public static readonly CONNECTING = 0;\n    public static readonly OPEN = 1;\n    public static readonly CLOSING = 2;\n    public static readonly CLOSED = 3;\n\n    public onclose: ((event: CloseEvent) => void) | null = null;\n    public onerror: ((event: Event) => void) | null = null;\n    public onmessage: ((event: MessageEvent) => void) | null = null;\n    public onopen: ((event: Event) => void) | null = null;\n    public ondown: ((event: CloseEvent | undefined) => void) | null = null;\n    public onreopen: ((event: Event) => void) | null = null;\n    public readonly CONNECTING = SturdyWebSocket.CONNECTING;\n    public readonly OPEN = SturdyWebSocket.OPEN;\n    public readonly CLOSING = SturdyWebSocket.CLOSING;\n    public readonly CLOSED = SturdyWebSocket.CLOSED;\n\n    private readonly protocols?: string | string[];\n    private readonly options: Required<Options>;\n    private ws?: WebSocket;\n    private hasBeenOpened = false;\n    private isClosed = false;\n    private messageBuffer: any[] = [];\n    private nextRetryTime: number = 0;\n    private reconnectCount = 0;\n    private allClearTimeoutId?: any;\n    private connectTimeoutId?: any;\n    private binaryTypeInternal?: BinaryType;\n    private lastKnownExtensions = \"\";\n    private lastKnownProtocol = \"\";\n    private readonly listeners: WebSocketListeners = {};\n\n    constructor(url: string, options?: Options);\n    constructor(\n        url: string,\n        protocols: string | string[] | undefined,\n        options?: Options,\n    );\n    constructor(\n        public readonly url: string,\n        protocolsOrOptions?: string | string[] | Options,\n        options: Options = {},\n    ) {\n        if (\n            protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)\n        ) {\n            this.protocols = protocolsOrOptions;\n        } else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            } else {\n                throw new Error(\n                    \"WebSocket not present in global scope and no \" +\n                        \"wsConstructor option was provided.\",\n                );\n            }\n        }\n        this.openNewWebSocket();\n    }\n\n    public get binaryType(): BinaryType {\n        return this.binaryTypeInternal || \"blob\";\n    }\n\n    public set binaryType(binaryType: BinaryType) {\n        this.binaryTypeInternal = binaryType;\n        if (this.ws) {\n            this.ws.binaryType = binaryType;\n        }\n    }\n\n    public get bufferedAmount(): number {\n        let sum = this.ws ? this.ws.bufferedAmount : 0;\n        let hasUnknownAmount = false;\n        this.messageBuffer.forEach(data => {\n            const byteLength = getDataByteLength(data);\n            if (byteLength != null) {\n                sum += byteLength;\n            } else {\n                hasUnknownAmount = true;\n            }\n        });\n        if (hasUnknownAmount) {\n            this.debugLog(\n                \"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\",\n            );\n        }\n        return sum;\n    }\n\n    public get extensions(): string {\n        return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n    }\n\n    public get protocol(): string {\n        return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n    }\n\n    public get readyState(): number {\n        return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n    }\n\n    public close(code?: number, reason?: string): void {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    }\n\n    public send(data: any): void {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        } else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        } else {\n            this.messageBuffer.push(data);\n        }\n    }\n\n    public reconnect(): void {\n        if (this.isClosed) {\n            throw new Error(\n                \"Cannot call reconnect() on socket which is permanently closed.\",\n            );\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    }\n\n    public addEventListener<K extends keyof SturdyWebSocketEventMap>(\n        type: K,\n        listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void,\n    ): void;\n    public addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void;\n    public addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    }\n\n    public dispatchEvent(event: Event): boolean {\n        return this.dispatchEventOfType(event.type, event);\n    }\n\n    public removeEventListener<K extends keyof SturdyWebSocketEventMap>(\n        type: K,\n        listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void,\n    ): void;\n    public removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void;\n    public removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(\n                l => l !== listener,\n            );\n        }\n    }\n\n    private openNewWebSocket(): void {\n        if (this.isClosed) {\n            return;\n        }\n        const { connectTimeout, wsConstructor } = this.options;\n        this.debugLog(`Opening new WebSocket to ${this.url}.`);\n        const ws: WebSocket = new wsConstructor(this.url, this.protocols);\n        ws.onclose = event => this.handleClose(event);\n        ws.onerror = event => this.handleError(event);\n        ws.onmessage = event => this.handleMessage(event);\n        ws.onopen = event => this.handleOpen(event);\n        this.connectTimeoutId = setTimeout(() => {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            this.clearConnectTimeout();\n            this.disposeSocket();\n            this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    }\n\n    private handleOpen(event: Event): void {\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        const { allClearResetTime } = this.options;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        } else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        } else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(message => this.send(message));\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(() => {\n            this.clearAllClearTimeout();\n            this.nextRetryTime = 0;\n            this.reconnectCount = 0;\n            const openTime = (allClearResetTime / 1000) | 0;\n            this.debugLog(\n                `WebSocket remained open for ${openTime} seconds. Resetting` +\n                    \" retry time and count.\",\n            );\n        }, allClearResetTime);\n    }\n\n    private handleMessage(event: MessageEvent): void {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    }\n\n    private handleClose(event: CloseEvent | undefined): void {\n        if (this.isClosed) {\n            return;\n        }\n        const { maxReconnectAttempts, shouldReconnect } = this.options;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(\n                event,\n                this.getTooManyFailedReconnectsMessage(),\n            );\n            return;\n        }\n        const willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(\n                willReconnect,\n                event,\n                SHOULD_RECONNECT_FALSE_MESSAGE,\n            );\n        } else {\n            willReconnect.then(willReconnectResolved => {\n                if (this.isClosed) {\n                    return;\n                }\n                this.handleWillReconnect(\n                    willReconnectResolved,\n                    event,\n                    SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE,\n                );\n            });\n        }\n    }\n\n    private handleError(event: Event): void {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    }\n\n    private handleWillReconnect(\n        willReconnect: boolean,\n        event: CloseEvent | undefined,\n        denialReason: string,\n    ): void {\n        if (willReconnect) {\n            this.reestablishConnection();\n        } else {\n            this.stopReconnecting(event, denialReason);\n        }\n    }\n\n    private reestablishConnection(): void {\n        const {\n            minReconnectDelay,\n            maxReconnectDelay,\n            reconnectBackoffFactor,\n        } = this.options;\n        this.reconnectCount++;\n        const retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(\n            minReconnectDelay,\n            Math.min(\n                this.nextRetryTime * reconnectBackoffFactor,\n                maxReconnectDelay,\n            ),\n        );\n        setTimeout(() => this.openNewWebSocket(), retryTime);\n        const retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\n            `WebSocket was closed. Re-opening in ${retryTimeSeconds} seconds.`,\n        );\n    }\n\n    private stopReconnecting(\n        event: CloseEvent | undefined,\n        debugReason: string,\n    ): void {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    }\n\n    private shutdown(): void {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    }\n\n    private disposeSocket(closeCode?: number, reason?: string): void {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    }\n\n    private clearAllTimeouts(): void {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    }\n\n    private clearConnectTimeout(): void {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    }\n\n    private clearAllClearTimeout(): void {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    }\n\n    private dispatchEventOfType(type: string, event: any): boolean {\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(listener => this.callListener(listener, event));\n        }\n        return !event || !(event as Event).defaultPrevented;\n    }\n\n    private callListener(\n        listener: EventListenerOrEventListenerObject,\n        event: Event,\n    ): void {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        } else {\n            listener.handleEvent.call(this, event);\n        }\n    }\n\n    private debugLog(message: string): void {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    }\n\n    private getTooManyFailedReconnectsMessage(): string {\n        const { maxReconnectAttempts } = this.options;\n        return `Failed to reconnect after ${maxReconnectAttempts} ${pluralize(\n            \"attempt\",\n            maxReconnectAttempts,\n        )}. Closing permanently.`;\n    }\n}\n\nfunction applyDefaultOptions(options: Options): Required<Options> {\n    const result: any = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(key => {\n        const value = (options as any)[key];\n        result[key] =\n            value === undefined\n                ? (SturdyWebSocket.DEFAULT_OPTIONS as any)[key]\n                : value;\n    });\n    return result;\n}\n\nfunction getDataByteLength(data: any): number | undefined {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    } else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    } else if (data instanceof Blob) {\n        return data.size;\n    } else {\n        return undefined;\n    }\n}\n\nfunction pluralize(s: string, n: number): string {\n    return n === 1 ? s : `${s}s`;\n}\n\nfunction noop(): void {\n    // Nothing.\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}