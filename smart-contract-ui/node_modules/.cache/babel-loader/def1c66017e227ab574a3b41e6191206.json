{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\n/**\n * Helper for converting functions which take a callback as their final argument\n * to functions which return a promise.\n */\nexport function promisify(f) {\n  return new Promise(function (resolve, reject) {\n    return f(function (error, result) {\n      if (error != null) {\n        reject(error);\n      } else {\n        resolve(result);\n      }\n    });\n  });\n}\n/**\n * Helper for converting functions which return a promise to functions which\n * take a callback as their final argument.\n */\nexport function callWhenDone(promise, callback) {\n  promise.then(function (result) {\n    callback(null, result);\n  }, function (error) {\n    callback(error);\n  });\n}\nexport function delay(ms) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, ms);\n  });\n}\nexport function withTimeout(promise, ms) {\n  return Promise.race([promise, new Promise(function (_, reject) {\n    return setTimeout(function () {\n      return reject(new Error(\"Timeout\"));\n    }, ms);\n  })]);\n}\nvar MIN_RETRY_DELAY = 1000;\nvar RETRY_BACKOFF_FACTOR = 2;\nvar MAX_RETRY_DELAY = 30000;\nexport function withBackoffRetries(f, retryCount, shouldRetry) {\n  if (shouldRetry === void 0) {\n    shouldRetry = function () {\n      return true;\n    };\n  }\n  return __awaiter(this, void 0, void 0, function () {\n    var nextWaitTime, i, error_1;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          nextWaitTime = 0;\n          i = 0;\n          _a.label = 1;\n        case 1:\n          if (!true) return [3 /*break*/, 7];\n          _a.label = 2;\n        case 2:\n          _a.trys.push([2, 4,, 6]);\n          return [4 /*yield*/, f()];\n        case 3:\n          return [2 /*return*/, _a.sent()];\n        case 4:\n          error_1 = _a.sent();\n          i++;\n          if (i >= retryCount || !shouldRetry(error_1)) {\n            throw error_1;\n          }\n          return [4 /*yield*/, delay(nextWaitTime)];\n        case 5:\n          _a.sent();\n          if (!shouldRetry(error_1)) {\n            throw error_1;\n          }\n          nextWaitTime = nextWaitTime === 0 ? MIN_RETRY_DELAY : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n          return [3 /*break*/, 6];\n        case 6:\n          return [3 /*break*/, 1];\n        case 7:\n          return [2 /*return*/];\n      }\n    });\n  });\n}\n\nexport function makeCancelToken() {\n  var cancelled = false;\n  return {\n    cancel: function () {\n      return cancelled = true;\n    },\n    isCancelled: function () {\n      return cancelled;\n    }\n  };\n}\nexport function throwIfCancelled(isCancelled) {\n  if (isCancelled()) {\n    throw CANCELLED;\n  }\n}\nexport var CANCELLED = new Error(\"Cancelled\");","map":{"version":3,"sources":["../../../src/util/promises.ts"],"names":[],"mappings":"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","sourcesContent":["import { Web3Callback } from \"../types\";\n\n/**\n * Helper for converting functions which take a callback as their final argument\n * to functions which return a promise.\n */\nexport function promisify<T>(\n  f: (callback: Web3Callback<T>) => void,\n): Promise<T> {\n  return new Promise((resolve, reject) =>\n    f((error, result) => {\n      if (error != null) {\n        reject(error);\n      } else {\n        resolve(result!);\n      }\n    }),\n  );\n}\n\n/**\n * Helper for converting functions which return a promise to functions which\n * take a callback as their final argument.\n */\nexport function callWhenDone<T>(\n  promise: Promise<T>,\n  callback: Web3Callback<T>,\n): void {\n  promise.then(\n    (result) => {\n      callback(null, result);\n    },\n    (error) => {\n      callback(error);\n    },\n  );\n}\n\nexport function delay(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function withTimeout<T>(promise: Promise<T>, ms: number): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) =>\n      setTimeout(() => reject(new Error(\"Timeout\")), ms),\n    ),\n  ]);\n}\n\nconst MIN_RETRY_DELAY = 1000;\nconst RETRY_BACKOFF_FACTOR = 2;\nconst MAX_RETRY_DELAY = 30000;\n\nexport async function withBackoffRetries<T>(\n  f: () => Promise<T>,\n  retryCount: number,\n  shouldRetry: (error: unknown) => boolean = () => true,\n): Promise<T> {\n  let nextWaitTime = 0;\n  let i = 0;\n  while (true) {\n    try {\n      return await f();\n    } catch (error) {\n      i++;\n      if (i >= retryCount || !shouldRetry(error)) {\n        throw error;\n      }\n      await delay(nextWaitTime);\n      if (!shouldRetry(error)) {\n        throw error;\n      }\n      nextWaitTime =\n        nextWaitTime === 0\n          ? MIN_RETRY_DELAY\n          : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n    }\n  }\n}\n\nexport interface CancelToken {\n  cancel(): void;\n  isCancelled(): boolean;\n}\n\nexport function makeCancelToken(): CancelToken {\n  let cancelled = false;\n  return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\n}\n\nexport function throwIfCancelled(isCancelled: () => boolean): void {\n  if (isCancelled()) {\n    throw CANCELLED;\n  }\n}\n\nexport const CANCELLED = new Error(\"Cancelled\");\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}